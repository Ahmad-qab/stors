

#' check grid validity
#'
#' @return boolian
#' @import digest digest
is_valid_grid = function(grid){
  
  stopifnot(" This grid is not optmized using  bvbuild_grid() " = digest(grid) %in% stors_env$created_girds_Id )
  
}

cash_grid_c <- function(Cnum, grid) {
  .Call(C_cache_grid, Cnum, grid$grid_data$x, grid$grid_data$s_upper, grid$grid_data$p_a, grid$grid_data$s_upper_lower, grid$areas, grid$steps_number, grid$sampling_probabilities, grid$unif_scaler, grid$lt_properties, grid$rt_properties, grid$alpha)
}


save_builtin_grid <- function(Cnum, grid) {
  
  grids_file_path <- file.path(stors_env$user_dirs$builtin_dir, paste0(Cnum, ".rds"))
  
  saveRDS(grid, grids_file_path)
}


#' Save User Grid
#'
#' @description
#' This function stores grids generated by the `build_grid()` function. It is useful when users want to reuse a grid across multiple R sessions.
#'
#' @param grid list representing an optimized grid generated using the `build_grid()` function.
#' @param grid_name string specifying the name under which the grid will be saved.
#'
#' @return
#' This function will produce an error if the grid is not generated by the `build_grid()` function. Otherwise, it successfully saves the grid without returning any value upon completion.
#' @export
#' 
#' 
#' @import digest digest
save_grid <- function(grid, grid_name) {
  
  is_valid_grid(grid)
  
  grids_file_path <- file.path(stors_env$user_dirs$data_dir, paste0(grid_name, ".rds"))
  
  saveRDS(grid, grids_file_path)
  
  efficiency <- (1/sum(grid$areas))
  
  stors_env$grids$user[ nrow(stors_env$grids$user) + 1 ,] = list( grid_name, efficiency)
}


#' Delete Stored Grid
#'
#' @description
#' Deletes a grid previously stored by the user using the `save_grid()` function.
#'
#' @param grid_name string specifying the name of the grid to be deleted.
#'
#' @return
#' Shows an error if `grid_name` does not exist. Otherwise, it successfully deletes the grid without returning any value upon completion.
#' 
#' @export
#'
delete_grid <- function(grid_name){
  
  stopifnot("this grid is not exist " = grid_name %in% stors_env$grids$user$name)
  
  file.remove(file.path( stors_env$user_dirs$data_dir, paste0(grid_name,".rds") ))
  stors_env$grids$user = stors_env$grids$user[stors_env$grids$user$name != grid_name,]
  cat(grid_name, "has been deleted successfully")

}


#' Load Stored Grid
#'
#' @description
#' This function loads a grid into memory that was previously saved using the `save_grid()` function.
#'
#' @param grid_name A string specifying the name of the grid to be loaded.
#'
#' @return
#' Returns a list of the grid stored under `grid_name` in R's internal data directory. If the specified grid name does not exist, it shows an error.
#' 
#' @export
#'
#' @examples
load_grid <- function(grid_name) {
  
  stopifnot("this grid is not exist"= grid_name %in% stors_env$grids$user$name)
  
  grids_file_path <- file.path(stors_env$user_dirs$data_dir, paste0(grid_name, ".rds"))
  
  grid <- readRDS(grids_file_path)
  
  stors_env$created_girds_Id  = append(stors_env$created_girds_Id , digest(grid))
  
  return(grid)
  
}




#' Build User Grid
#'
#' @description
#' This function is used to create an optimized grid representing the proposal distribution for a target density, especially when sampling from certain density functions not prebuilt in stors, such as `srnorm` and `srgamma`.
#'
#' @param lb Scalar target density lower bound.
#' @param rb Scalar target density upper bound.
#' @param mode Vector representing the modes of the density.
#' @param f Function accepting one argument which returns the probability density of the target.
#' @param h Function accepting one argument which returns the Log-transform of the target.
#' @param h_prime Function accepting one argument which returns the first derivative of the log-transformed target density.
#'
#' @details
#' The grid building is conducted through constant area rectangles starting from the target distribution modes. For each mode, steps are constructed around as rectangles with a width of \(x_i - x_{i-1}\) and a height determined by \(\max(f(x_{i-1}), f(x_i))\), effectively covering the target distribution in a step pattern. The function grid_builder() constructs these steps and computes values that contribute to the sampling process. These values are later cached when the resulting grid is passed to the stors() function. This approach enhances the computational efficiency of stors.
#' 
#' 
#' @return
#' Returns a list that contains the following data that is related to the proposal distribution:
#' \itemize{
#' \item{"grid_data"} {Data frame that includes the created steps information, such as x (the beginning of each step on the x-axis), s_upper (the step height on the y-axis), p_a (pre-acceptance probability for each step), and s_upper_lower (a vector used to re-scale the uniform random number when the sample is accepted).}
#' \item{"areas"} {Vector that contains the area under the left tail bound, the steps in the middle, and the right tail bound.}
#' \item{"steps_number"} {Scalar representing the number of steps in the proposal.}
#' \item{"sampling_probabilities"} {Vector that contains the area under the left tail, and the area under the left tail and middle steps.}
#' \item{"unif_scaler"} {Scalar representing the inverse probability of sampling from the step part of the proposal, \eqn{\frac{1}{p(lb < x < rb)}}. This value, similar to s_upper_lower in the grid_data data frame, is used to scale the uniform random value under the condition that we are going to sample from the steps part of the proposal.}
#' \item{"lt_properties"} {Vector that includes 5 values used when sampling under the proposal's left tail using the ARS method.}
#' \item{"rt_properties"} {Vector that includes 6 values used when sampling under the proposal's right tail using the ARS method.}
#' }
#' @seealso [func()]
#' #\deqn{}
#' @examples
#' 
#' library(stors)
#' 
#' #EXAMPLE:1 The following example shows the grid building steps for a basic standard normal distribution f(x) \sim N(0,1)
#' 
#'  modes_norm = 0
#' 
#'   f_norm  <- function(x)  1/sqrt(2 * pi) * exp(-0.5 *x^2)
#'    
#'    h_norm <- function(x) log(f_norm(x))
#'    
#'    h_norm <- function(x) -x
#' 
#'  norm_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_norm, f = f_norm, h = h_norm, h_prime = h_norm)
#' 
#' 
#' #EXAMPLE:2  The following example demonstrates how to build a grid for sampling from a bimodal distribution, which is a combination of two normal distributions \( f(x) = 0.5 \cdot w_1(x) + 0.5 \cdot w_2(x) \), where \( w_1(x) \sim \mathcal{N}(0, 1) \) and \( w_2(x) \sim \mathcal{N}(4, 1) \).
#'  
#'  modes_bi = c(0,4)
#'  
#'  f_bi <- function(x) {
#'    0.5 * (sqrt(2 * pi))^(-1) * exp(-(x^2)/2) + 0.5 * ( sqrt(2 * pi))^(-1) * exp(-((x - 4)^2)/2)
#'    }
#'    
#'  h_bi <- function(x) log(f_bi(x))
#'    
#'  h_prime_bi <- function(x) {
#'      (-(exp(-1/2 * (-4 + x)^2) * 0.5 * (-4 + x))/sqrt(2 * pi) - (exp(-x^2/2) * 0.5 * x)/sqrt(2 * pi))/((exp(-x^2/2) * 0.5)/sqrt(2 * pi) + (exp(-1/2 * (-4 + x)^2) * 0.5)/sqrt(2 * pi))
#'      }
#'  
#'  bi_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_bi, f = f_bi, h = h_bi, h_prime = h_prime_bi)
#'  
#' @import digest digest
#' @export
build_grid <- function(lb = -Inf, rb = Inf, mode, f, h = NULL, h_prime = NULL, a = 0.01,th = 0.9) {

    # A <- seq(from = 0.005, to = 0.0002, length.out = 100)
    # 
    # for (a in A) {
    #   
    #   opt_grid <- grid_builder(lb, rb, a, th = 0.6, mode, f, h, h_prime)
    # 
    #   if ((object.size(opt_grid) / 1024) > 128) break
    # }
    # 
  if(is.null(h)){
    h <- function(x){log(f(x))}
  }
  
  if(is.null(h_prime)){
    h_prime <- stors_prime(mode[1], h)
  }
  
     opt_grid <- grid_builder(lb, rb,a, th, mode, f, h, h_prime)
    
    func_to_text <- deparse(f)

    opt_grid$dens_func <- func_to_text
    
    
    class(opt_grid) <- "grid"
    
    
    if(!(digest(opt_grid) %in% stors_env$created_girds_Id))
    stors_env$created_girds_Id  = append(stors_env$created_girds_Id , digest(opt_grid))
    
    
    return(opt_grid)
  
}


#' Grid Builder
#'
#' @param lb scaler density lower bound
#' @param rb scaler density upper bound
#' @param a scaler step area
#' @param th scaler pre_acceptance threshold
#' @param mode vector density modes
#' @param f density function
#' @param h log transform of the density function
#' @param h_prime first derivative of h
#' @return list including proposal distribution properties
#' @importFrom utils head
grid_builder <- function(lb = -Inf, rb = Inf, a, th, mode, f, h, h_prime) {
  mode_n <- length(mode)

  final_grid <- data.frame(
    x = c(), s_upper = c(), s_lower = c(), p_a = c(),
    s_upper_lower = c()
  )
  
  grids <- list()
  area <- c(0, 0, 0)
  g_len <- c()

  for (mode_i in (1:mode_n)) {
    grids[[mode_i]] <- find_steps(lb = -Inf, rb = Inf, a, th, mode[mode_i], mode_i, mode_n, f, h_prime, h)
  }


  if (mode_n > 1) {
    for (i in (1:(mode_n - 1))) {
      if (grids[[i]]$d$x[grids[[i]]$m + 1] > grids[[i + 1]]$d$x[1]) {
        if (grids[[i]]$d$s_upper[grids[[i]]$m] > grids[[i + 1]]$d$s_upper[1]) {
          grids[[i]]$d <- head(grids[[i]]$d, -1)

          grids[[i]]$d$s_upper[grids[[i]]$m] <- a / (grids[[i + 1]]$d$x[1] - grids[[i]]$d$x[grids[[i]]$m])

          grids[[i]]$d$p_a[grids[[i]]$m] <- 0

          grids[[i + 1]]$d$p_a[1] <- 0
        } else {
          grids[[i + 1]]$d$x[1] <- grids[[i]]$d$x[grids[[i]]$m + 1]

          grids[[i]]$d <- head(grids[[i]]$d, -1)


          grids[[i + 1]]$d$s_upper[1] <- a / (grids[[i + 1]]$d$x[2] - grids[[i + 1]]$d$x[1])

          grids[[i + 1]]$d$p_a[1] <- 0

          grids[[i]]$d$p_a[grids[[i]]$m] <- 0
        }
      } else {
        grids[[i]]$m <- grids[[i]]$m + 1

        grids[[i]]$d$s_upper[grids[[i]]$m] <- a / (grids[[i + 1]]$d$x[1] - grids[[i]]$d$x[grids[[i]]$m])

        grids[[i]]$d$p_a[grids[[i]]$m] <- 0
      }

      m1 <- grids[[i]]$m

      m2 <- grids[[i + 1]]$m




      area[2] <- area[2] + m1 * a

      g_len[length(g_len) + 1] <- m1



      if (i == (mode_n - 1)) {
        final_grid <- rbind(final_grid, grids[[i]]$d, grids[[i + 1]]$d)

        area[2] <- area[2] + m2 * a

        g_len[length(g_len) + 1] <- m2
      } else {
        final_grid <- rbind(final_grid, grids[[i]]$d)
      }
    }
  } else {
    final_grid <- grids[[1]]$d

    area[2] <- grids[[1]]$m * a

    g_len[length(g_len) + 1] <- grids[[1]]$m
  }

  tails_area = tails_ars(final_grid, f, h, h_prime, lb, rb)
  
  area[1] <- tails_area$lta
  
  area[3] <- tails_area$rta
  
  print(tails_area$lta)
  print(tails_area$rta)
  

  normalizing_con <- sum(area)

  area_cum_sum <- cumsum(area)

  sampling_probabilities <- (area_cum_sum / normalizing_con)[1:2]

  steps_number <- sum(g_len) # m

  unif_scaler <- normalizing_con / area[2]

  
  
  x1 <- final_grid$x[1]
  xm <- final_grid$x[steps_number + 1]
  
  lt_properties <- c(exp(h_upper(x1, lb, h_prime, h)), normalizing_con * h_prime(x1), h(x1), 1 / h_prime(x1), h_prime(x1)) #4
  rt_properties <- c(normalizing_con, area_cum_sum[2], h_prime(xm) / f(xm), 1 / h_prime(xm), h_prime(xm), h(xm))

  invisible(list(grid_data = final_grid, areas = area, steps_number = steps_number, sampling_probabilities = sampling_probabilities, unif_scaler = unif_scaler, lt_properties = lt_properties, rt_properties = rt_properties, alpha = a))
}




#' Steps Builder
#'
#' @param lb scaler density lower bound
#' @param rb scaler density upper bound
#' @param a scaler step area
#' @param th scaler pre_acceptance threshold
#' @param mode vector density modes
#' @param mode_i mode index
#' @param mode_n total number of modes
#' @param f density function
#' @param h log transform of the density function
#' @param h_prime first derivative of h
#'
#' @return
#'
#' @examples
find_steps <- function(lb = -Inf, rb = Inf, a, th, mode, mode_i, mode_n, f, h_prime, h) {
  memory_res <- (max(500, ceiling(1 / a)) + 500) / 2

  x <- rep(NA, memory_res * 2 + 1)
  s_upper <- rep(NA, memory_res * 2 + 1)
  s_lower <- rep(NA, memory_res * 2 + 1)
  p_a <- rep(NA, memory_res * 2 + 1)
  s_upper_lower <- rep(NA, memory_res * 2 + 1)


  r <- 0
  l <- 0

  i <- memory_res + 1


  if (mode != rb) {
    x_c <- mode

    f_x <- f(x_c)

    while (TRUE) {
      x_next <- x_c + a / f_x

      if (x_next > rb || (mode_i == mode_n && f(x_next) / f_x < th)) {
        x[i + r] <- x_c
        break
      }

      f_x_next <- f(x_next)

      if (f_x_next > f_x) {
        x[i + r] <- x_c
        s_upper[i + r] <- f_x
        r_tail_area <- 0
        break
      }


      x[i + r] <- x_c
      s_upper[i + r] <- f_x
      s_lower[i + r] <- f_x_next
      s_upper_lower[i + r] <- s_upper[i + r] / s_lower[i + r]
      p_a[i + r] <- s_lower[i + r] / s_upper[i + r]


      f_x <- f_x_next
      x_c <- x_next

      r <- r + 1
    }
  }



  if (mode != lb) {
    x_previous <- mode
    f_x_previous <- f(x_previous)


    while (TRUE) {
      x_c <- x_previous - a / f_x_previous



      if (x_c < lb || (mode_i == 1 && f(x_c) / f_x_previous  < th)) {
        break
      }

      f_x <- f(x_c)

      if (f(x_c) > f_x_previous) {
        # l_tail_area <- 0
        break
      }

      l <- l + 1
      x[i - l] <- x_c
      s_upper[i - l] <- f_x_previous
      s_lower[i - l] <- f_x
      s_upper_lower[i - l] <- s_upper[i - l] / s_lower[i - l]

      p_a[i - l] <- f_x / f_x_previous


      f_x_previous <- f_x
      x_previous <- x_c
    }
  }

  m <- l + r

  d <- data.frame(
    x = x, s_upper = s_upper, p_a = p_a,
    s_upper_lower = s_upper_lower
  )

  d <- subset(d, rowSums(is.na(d)) != ncol(d))

  return(list(d = d, m = m))
}



h_upper <- function(grid_point, val, h_prime, h) {
  h_prime(grid_point) * (val - grid_point) + h(grid_point)
}

# h_prime_lb <- function(x, h){
#   x0 = x
#   x00 = x0 + 0.0000001
#   (h(x00) - h(x0))/(x00 -x0)
# }
# 
# 
# h_prime_rb <- function(x, h){
#   xm = x
#   xmm = xm - 0.0000001
#   (h(xmm) - h(xm))/(xmm -xm)
# }
# 
# 
# h_prime <- function(x){
#   
#   return(x^2)
# }


tails_ars <- function(grid, f, h, h_prime, lb, rb){
  m = length(grid$x)
  # left tail
  if (lb == Inf) {
    l_tail_area <- (1 / h_prime(grid$x[1])) * f(grid$x[1])
  } else {
    l_tail_area <- (1 / h_prime(grid$x[1])) * (f(grid$x[1]) - exp(h_upper(grid$x[1], lb, h_prime, h)))
  }
  
  #right tails
  if (rb == Inf) {
    r_tail_area <- (1 / h_prime(grid$x[m])) * -f(grid$x[m])
  } else {
    r_tail_area <- (1 / h_prime(grid$x[m])) * (exp(h_upper(grid$x[m], rb, h_prime, h)) - f(grid$x[m]))
  }
  
  return(list(lta = l_tail_area, rta = r_tail_area))
  
}

stors_prime <-function(mode, h){

    function(x){
      if(x < mode){
        x0 = x + 0.0000001
      }else{
        x0 = x - 0.0000001
      }
      (h(x0) - h(x))/(x0 -x)
    }

}
