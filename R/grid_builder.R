# pbgrids : 1 Normal

pbgrids <- list(
  srnorm = c(
    Cnum = 0,
    f = function(x) {
      0.3989423 * exp(-0.5 * x * x)
    },
    h = function(x) {
      log(0.3989423) - (x * x) * (1 / 2)
    },
    h_prime = function(x) {
      -x
    },
    modes = 0,
    lb = -Inf,
    rb = Inf
  )
)


#' check grid validity
#'
#' @return boolian
#' @import digest digest
is_valid_grid = function(grid){
  
  stopifnot(" This grid is not optmized using build_grid() " = digest(grid) %in% stors_env$created_girds_Id )
  
}

#' Optimize Built-in Grid
#'
#' @description
#' This function optimizes and stores the sampling grid for STROS built-in distributions.
#'
#' @param density_name string specifying the name of the distribution.
#'
#' @details
#' Before users can sample from a built-in distribution in the STROS package, they must first optimize the sampling grid using this function.
#'
#' @seealso [srnorm]
#'
#' @examples
#' # optimize grid to sample 10 values from normal distribution N(0,1) 
#' library(stors)
#' grid_optimizer("srnorm")
#' srnorm(10)
#'
#' @return
#' This function generates and stores an optimized grid for the specified built-in distribution in R's internal data directory.
#' 
#' @export
grid_optimizer <- function(density_name = c("srnorm")) {
  
  density_name <- match.arg(density_name)

  stopifnot(" Grid already optimized for this distrubution" = !stors_env$grids$biultin[[density_name]]$opt)

  
  dendata <- pbgrids[[density_name]]

  A <- seq(from = 0.005, to = 0.0002, length.out = 100)

  for (a in A) {
    opt_grid <- grid_builder(a = a, th = 0.6, mode = dendata$modes, f = dendata$f, h = dendata$h, h_prime = dendata$h_prime)

    if ((object.size(opt_grid) / 1024) > 128) break
  }

  opt_grid <- grid_builder(a = 0.00035, th = 0.6, mode = dendata$modes, f = dendata$f, h = dendata$h, h_prime = dendata$h_prime)

  cash_grid_c(dendata$Cnum, opt_grid)

  save_builtin_grid(dendata$Cnum, opt_grid)

  stors_env$grids$biultin[[density_name]]$opt <- TRUE
  
}


cash_grid_c <- function(Cnum, grid) {
  .Call(C_cache_grid, Cnum, grid$grid_data$x, grid$grid_data$s_upper, grid$grid_data$p_a, grid$grid_data$s_upper_lower, grid$areas, grid$steps_number, grid$sampling_probabilities, grid$unif_scaler, grid$lt_properties, grid$rt_properties)
}


save_builtin_grid <- function(Cnum, grid) {
  
  grids_file_path <- file.path(stors_env$user_dirs$builtin_dir, paste0(Cnum, ".rds"))
  
  saveRDS(grid, grids_file_path)
}



#' @method print grid
#' @export
print.grid <-function(grid, ...){
  
   cat("The grid has ", grid$steps_number ," steps, in the domain range [", grid$grid_data$x[1] ,",", grid$grid_data$x[grid$steps_number+1],"].\n")
   cat(sprintf("With a sampling efficiency of %.2f%%", 1/sum(grid$areas) * 100))
   
}



#' @method plot grid
#' @export
plot.grid <- function(grid, ...){
  
  n = nrow(grid$grid_data)
  
  lf  <- function(x) exp( grid$lt_properties[5] * (x - grid$grid_data$x[1]) + grid$lt_properties[3] )

  rf  <- function(x) exp( grid$rt_properties[5] * (x - grid$grid_data$x[n]) + grid$rt_properties[6] )
  

  f <- eval(parse(text = grid$dens_func))
  
  
  xx <- seq(from = grid$grid_data$x[1]-1, to = grid$grid_data$x[n]+1, by = 0.01)
  
  xl <- seq( from = grid$grid_data$x[1]-1 , to= grid$grid_data$x[1], by = 0.01)
  
  xr <- seq( from = grid$grid_data$x[n] , to= grid$grid_data$x[n]+1, by = 0.01)
  
  yy <- f(xx)
  
  yl <- lf(xl)
  
  yr <- rf(xr)
  
  grid$grid_data$s_upper[n] = yr[1]
  
  grid$grid_data = rbind( c(grid$grid_data$x[1],yl[length(yl)],NA,NA), grid$grid_data)
  
  n <- n+1
  
  if (requireNamespace("ggplot2")) {
    
    ggplot2::ggplot() +
      ggplot2::geom_step(ggplot2::aes(grid$grid_data[1:(n),]$x, grid$grid_data[1:(n),]$s_upper)) +
      ggplot2::geom_line(ggplot2::aes(x = xx, y = yy, colour = "red"))  +
      ggplot2::geom_line(ggplot2::aes(x = xl, y = yl, colour = "black")) +
      ggplot2::geom_line(ggplot2::aes(x = xr, y = yr, colour = "black")) +
      coord_cartesian(ylim=c(0, max(yy)))
      # ggplot2::scale_y_continuous(limits = c(0, max(yy)))
    
  } else{
    plot(grid,...)
  }
  
  
}

#' Save User Grid
#'
#' @description
#' This function stores grids generated by the `build_grid()` function. It is useful when users want to reuse a grid across multiple R sessions.
#'
#' @param grid list representing an optimized grid generated using the `build_grid()` function.
#' @param grid_name string specifying the name under which the grid will be saved.
#'
#' @return
#' This function will produce an error if the grid is not generated by the `build_grid()` function. Otherwise, it successfully saves the grid without returning any value upon completion.
#' @export
#' @import digest digest
save_grid <- function(grid, grid_name) {
  
  is_valid_grid(grid)
  
  grids_file_path <- file.path(stors_env$user_dirs$data_dir, paste0(grid_name, ".rds"))
  
  saveRDS(grid, grids_file_path)
  
  efficiency <- (1/sum(grid$areas))
  
  stors_env$grids$user[ nrow(stors_env$grids$user) + 1 ,] = list( grid_name, efficiency)
}


#' Print All Grids
#'
#' @description
#' Prints details of all grids stored by the user, including grid name, size, efficiency, etc.
#'
#' @export
#'
#' @examples
#' # To print details of all stored grids
#' print_grids()
print_grids <- function( ){
  
  stopifnot(" there are no grids stored by the user " = nrow(stors_env$grids$user) != 0)
  
  grids <- list.files(path = stors_env$user_dirs$data_dir, full.names = TRUE)
  
  grids_details <- file.info(grids)
  
  grids_sizes <- grids_details[grids_details$isdir == FALSE,]$size
  
  print(stors_env$grids$user)
  
  cat("\n grids_size : ", sum(as.double(grids_sizes))/1028," KB")
  
}


#' Delete Stored Grid
#'
#' @description
#' Deletes a grid previously stored by the user using the `save_grid()` function.
#'
#' @param grid_name string specifying the name of the grid to be deleted.
#'
#' @return
#' Shows an error if `grid_name` does not exist. Otherwise, it successfully deletes the grid without returning any value upon completion.
#' 
#' @export
#'
delete_grid <- function(grid_name){
  
  stopifnot("this grid is not exist " = grid_name %in% stors_env$grids$user$name)
  
  file.remove(file.path( stors_env$user_dirs$data_dir, paste0(grid_name,".rds") ))
  stors_env$grids$user = stors_env$grids$user[stors_env$grids$user$name != grid_name,]
  cat(grid_name, "has been deleted successfully")

}


#' Load Stored Grid
#'
#' @description
#' This function loads a grid into memory that was previously saved using the `save_grid()` function.
#'
#' @param grid_name A string specifying the name of the grid to be loaded.
#'
#' @return
#' Returns a list of the grid stored under `grid_name` in R's internal data directory. If the specified grid name does not exist, it shows an error.
#' 
#' @export
#'
#' @examples
load_grid <- function(grid_name) {
  
  stopifnot("this grid is not exist"= grid_name %in% stors_env$grids$user$name)
  
  grids_file_path <- file.path(stors_env$user_dirs$data_dir, paste0(grid_name, ".rds"))
  
  grid <- readRDS(grids_file_path)
  
  stors_env$created_girds_Id  = append(stors_env$created_girds_Id , digest(grid))
  
  return(grid)
  
}




#' Build User Grid
#'
#' @description
#' This function is used to create an optimized grid representing the proposal distribution for a target density, especially when sampling from certain density functions not prebuilt in STROS, such as `srnorm` and `srgamma`.
#'
#' @param lb Scalar representing the lower bound of the density.
#' @param rb Scalar representing the upper bound of the density.
#' @param mode Scalar/vector representing the modes of the density.
#' @param f The target density function.
#' @param h Log transform of the target density function.
#' @param h_prime The first derivative of the log-transformed target density.
#'
#' @return
#' Returns a list containing all details of the proposal or sampling grid.
#'
#' @examples
#' # The following example demonstrates how to build a grid for sampling from a bimodal distribution, which is a combination of two normal distributions \( f(x) = 0.5 \cdot w_1(x) + 0.5 \cdot w_2(x) \), where \( w_1(x) \sim \mathcal{N}(0, 1) \) and \( w_2(x) \sim \mathcal{N}(4, 1) \).
#'  
#'  modes_bi = c(0,4)
#'  
#'  f_bi <- function(x) {
#'    0.5 * (sqrt(2 * pi))^(-1) * exp(-(x^2)/2) + 0.5 * ( sqrt(2 * pi))^(-1) * exp(-((x - 4)^2)/2)
#'    }
#'    
#'  h_bi <- function(x) log(f_bi(x))
#'    
#'  h_prime_bi <- function(x) {
#'      (-(exp(-1/2 * (-4 + x)^2) * 0.5 * (-4 + x))/sqrt(2 * pi) - (exp(-x^2/2) * 0.5 * x)/sqrt(2 * pi))/((exp(-x^2/2) * 0.5)/sqrt(2 * pi) + (exp(-1/2 * (-4 + x)^2) * 0.5)/sqrt(2 * pi))
#'      }
#'  
#'  bi_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_bi, f = f_bi, h = h_bi, h_prime = h_prime_bi)
#'  
#' @import digest digest
#' @export
build_grid <- function(lb = -Inf, rb = Inf, mode, f = f_norm, h = h_norm, h_prime = h_prime_norm) {

    A <- seq(from = 0.005, to = 0.0002, length.out = 100)

    for (a in A) {
      
      opt_grid <- grid_builder(lb, rb, a, th = 0.6, mode, f, h, h_prime)

      if ((object.size(opt_grid) / 1024) > 128) break
    }
    
    # opt_grid <- grid_builder(lb, rb, 0.1, th = 0.8, mode, f, h, h_prime)
    

    func_to_text <- deparse(f)

    opt_grid$dens_func <- func_to_text
    
    
    class(opt_grid) <- "grid"
    
    
    if(!(digest(opt_grid) %in% stors_env$created_girds_Id))
    stors_env$created_girds_Id  = append(stors_env$created_girds_Id , digest(opt_grid))
    
    
    return(opt_grid)
  
}


#' Grid init
#'
#' @param lb scaler density lower bound
#' @param rb scaler density upper bound
#' @param a scaler step area
#' @param th scaler pre_acceptance threshold
#' @param mode vector density modes
#' @param f density function
#' @param h log transform of the density function
#' @param h_prime first derivative of h
#' @return list including proposal distribution properties
#' @importFrom utils head
grid_builder <- function(lb = -Inf, rb = Inf, a, th, mode, f, h, h_prime) {
  mode_n <- length(mode)

  final_grid <- data.frame(
    x = c(), s_upper = c(), s_lower = c(), p_a = c(),
    s_upper_lower = c()
  )
  grids <- list()
  area <- c(0, 0, 0)
  g_len <- c()

  for (mode_i in (1:mode_n)) {
    grids[[mode_i]] <- find_steps(lb = -Inf, rb = Inf, a, th, mode[mode_i], mode_i, mode_n, f, h_prime, h)
  }


  area[1] <- grids[[1]]$l_tail_area



  if (mode_n > 1) {
    for (i in (1:(mode_n - 1))) {
      if (grids[[i]]$d$x[grids[[i]]$m + 1] > grids[[i + 1]]$d$x[1]) {
        if (grids[[i]]$d$s_upper[grids[[i]]$m] > grids[[i + 1]]$d$s_upper[1]) {
          grids[[i]]$d <- head(grids[[i]]$d, -1)

          grids[[i]]$d$s_upper[grids[[i]]$m] <- a / (grids[[i + 1]]$d$x[1] - grids[[i]]$d$x[grids[[i]]$m])

          grids[[i]]$d$p_a[grids[[i]]$m] <- 0

          grids[[i + 1]]$d$p_a[1] <- 0
        } else {
          grids[[i + 1]]$d$x[1] <- grids[[i]]$d$x[grids[[i]]$m + 1]

          grids[[i]]$d <- head(grids[[i]]$d, -1)


          grids[[i + 1]]$d$s_upper[1] <- a / (grids[[i + 1]]$d$x[2] - grids[[i + 1]]$d$x[1])

          grids[[i + 1]]$d$p_a[1] <- 0

          grids[[i]]$d$p_a[grids[[i]]$m] <- 0
        }
      } else {
        grids[[i]]$m <- grids[[i]]$m + 1

        grids[[i]]$d$s_upper[grids[[i]]$m] <- a / (grids[[i + 1]]$d$x[1] - grids[[i]]$d$x[grids[[i]]$m])

        grids[[i]]$d$p_a[grids[[i]]$m] <- 0
      }

      m1 <- grids[[i]]$m

      m2 <- grids[[i + 1]]$m




      area[2] <- area[2] + m1 * a

      g_len[length(g_len) + 1] <- m1



      if (i == (mode_n - 1)) {
        final_grid <- rbind(final_grid, grids[[i]]$d, grids[[i + 1]]$d)

        area[2] <- area[2] + m2 * a

        g_len[length(g_len) + 1] <- m2
      } else {
        final_grid <- rbind(final_grid, grids[[i]]$d)
      }
    }
  } else {
    final_grid <- grids[[1]]$d

    area[2] <- grids[[1]]$m * a

    g_len[length(g_len) + 1] <- grids[[1]]$m
  }

  area[3] <- grids[[mode_n]]$r_tail_area

  normalizing_con <- sum(area)

  area_cum_sum <- cumsum(area)

  sampling_probabilities <- (area_cum_sum / normalizing_con)[1:2]

  steps_number <- sum(g_len) # m

  unif_scaler <- normalizing_con / area[2]

  x1 <- final_grid$x[1]
  xm <- final_grid$x[steps_number + 1]

  lt_properties <- c(exp(h_upper(x1, lb, h_prime, h)), normalizing_con * h_prime(x1), h(x1), 1 / h_prime(x1), h_prime(x1))
  rt_properties <- c(normalizing_con, area_cum_sum[2], h_prime(xm) / f(xm), 1 / h_prime(xm), h_prime(xm), h(xm))

  invisible(list(grid_data = final_grid, areas = area, steps_number = steps_number, sampling_probabilities = sampling_probabilities, unif_scaler = unif_scaler, lt_properties = lt_properties, rt_properties = rt_properties))
}

#' Steps Builder
#'
#' @param lb scaler density lower bound
#' @param rb scaler density upper bound
#' @param a scaler step area
#' @param th scaler pre_acceptance threshold
#' @param mode vector density modes
#' @param mode_i mode index
#' @param mode_n total number of modes
#' @param f density function
#' @param h log transform of the density function
#' @param h_prime first derivative of h
#'
#' @return
#'
#' @examples
find_steps <- function(lb = -Inf, rb = Inf, a, th, mode, mode_i, mode_n, f, h_prime, h) {
  memory_res <- (max(500, ceiling(1 / a)) + 500) / 2

  x <- rep(NA, memory_res * 2 + 1)
  s_upper <- rep(NA, memory_res * 2 + 1)
  s_lower <- rep(NA, memory_res * 2 + 1)
  p_a <- rep(NA, memory_res * 2 + 1)
  s_upper_lower <- rep(NA, memory_res * 2 + 1)


  r <- 0
  l <- 0

  i <- memory_res + 1


  if (mode != rb) {
    x_c <- mode

    f_x <- f(x_c)

    while (TRUE) {
      x_next <- x_c + a / f_x

      if (x_next > rb || (mode_i == mode_n && f(x_next) / f_x < th)) {
        x[i + r] <- x_c
        if (rb == Inf) {
          r_tail_area <- (1 / h_prime(x[i + r])) * -f(x[i + r])
        } else {
          r_tail_area <- (1 / h_prime(x[i + r])) * (exp(h_upper(x[i + r], rb, h_prime, h)) - f(x[i + r]))
        }


        break
      }

      f_x_next <- f(x_next)

      if (f_x_next > f_x) {
        x[i + r] <- x_c
        s_upper[i + r] <- f_x
        r_tail_area <- 0
        break
      }


      x[i + r] <- x_c
      s_upper[i + r] <- f_x
      s_lower[i + r] <- f_x_next
      s_upper_lower[i + r] <- s_upper[i + r] / s_lower[i + r]
      p_a[i + r] <- s_lower[i + r] / s_upper[i + r]


      f_x <- f_x_next
      x_c <- x_next

      r <- r + 1
    }
  }



  if (mode != lb) {
    x_previous <- mode
    f_x_previous <- f(x_previous)


    while (TRUE) {
      x_c <- x_previous - a / f_x_previous



      if (x_c < lb || (mode_i == 1 && f(x_c) / f_x_previous < th)) {
        if (lb == Inf) {
          l_tail_area <- (1 / h_prime(x[i - l])) * f(x[i - l])
        } else {
          l_tail_area <- (1 / h_prime(x[i - l])) * (f(x[i - l]) - exp(h_upper(x[i - l], lb, h_prime, h)))
        }
        break
      }

      f_x <- f(x_c)

      if (f(x_c) > f_x_previous) {
        l_tail_area <- 0
        break
      }

      l <- l + 1
      x[i - l] <- x_c
      s_upper[i - l] <- f_x_previous
      s_lower[i - l] <- f_x
      s_upper_lower[i - l] <- s_upper[i - l] / s_lower[i - l]

      p_a[i - l] <- f_x / f_x_previous


      f_x_previous <- f_x
      x_previous <- x_c
    }
  }

  m <- l + r

  d <- data.frame(
    x = x, s_upper = s_upper, p_a = p_a,
    s_upper_lower = s_upper_lower
  )

  d <- subset(d, rowSums(is.na(d)) != ncol(d))

  return(list(d = d, m = m, l_tail_area = l_tail_area, r_tail_area = r_tail_area))
}





h_upper <- function(grid_point, val, h_prime, h) {
  h_prime(grid_point) * (val - grid_point) + h(grid_point)
}
