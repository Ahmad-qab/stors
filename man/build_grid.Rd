% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_builder.R
\name{build_grid}
\alias{build_grid}
\title{Build User Grid}
\usage{
build_grid(
  lb = -Inf,
  rb = Inf,
  modes = NULL,
  f = NA,
  h = NULL,
  h_prime = NULL,
  steps = NULL,
  grid_range = NULL,
  theta = NULL,
  target_sample_size = 1000,
  verbose = FALSE
)
}
\arguments{
\item{lb}{Scalar representing the lower bound of the target density.}

\item{rb}{Scalar representing the upper bound of the target density.}

\item{modes}{Vector indicating the modes of the density function.}

\item{f}{Function accepting a single argument, returning the probability density of the target.}

\item{h}{Function accepting a single argument, returning the log-transform of the target density.}

\item{h_prime}{Function accepting a single argument, returning the first derivative of the log-transformed target density.}

\item{steps}{Optional Scalar integer indicating the number of steps in the proposal distribution.}

\item{grid_range}{Optional Vector of two elements specifying the start and end points for constructing steps along the x-axis.}

\item{theta}{Optional Scalar defining the pre-acceptance threshold,
dictating when the proposal steps constructing break based on the probability of pre-acceptance.}

\item{target_sample_size}{Scalar integer indicating the target sample size. The grid optimization process will take this number into account.}

\item{verbose}{Boolean if set to True, a table detailing the optimization areas and steps will be displayed during grid optimization.}
}
\value{
The returned list must be stored by the user, as it is required to be passed to the \code{\link{stors}} function.
The \code{stors} function uses the grid's properties to build and return a sampling function.

A list containing the optimized grid and related parameters for the specified built-in distribution:
\describe{
  \item{\code{grid_data}}{A data frame with detailed information about the grid steps, including:
  \describe{
    \item{\code{x}}{The start point of each step on the x-axis.}
    \item{\code{s_upper}}{The height of each step on the y-axis.}
    \item{\code{p_a}}{Pre-acceptance probability for each step.}
    \item{\code{s_upper_lower}}{A vector used to scale the uniform random number when the sample is accepted.}
  }}
  \item{\code{areas}}{A numeric vector containing the areas under:
  \describe{
    \item{\code{left_tail}}{The left tail bound.}
    \item{\code{steps}}{The middle steps.}
    \item{\code{right_tail}}{The right tail bound.}
  }}
  \item{\code{steps_number}}{An integer specifying the number of steps in the proposal.}
  \item{\code{sampling_probabilities}}{A numeric vector with:
  \describe{
    \item{\code{left_tail}}{The probability of sampling from the left tail.}
    \item{\code{left_and_middle}}{The combined probability of sampling from the left tail and middle steps.}
  }}
  \item{\code{unif_scaler}}{A numeric scalar, the inverse probability of sampling from the steps part of the proposal (\eqn{\frac{1}{p(lb < x < rb)}}). Used for scaling uniform random values.}
  \item{\code{lt_properties}}{A numeric vector of 5 values required for Adaptive Rejection Sampling (ARS) in the left tail.}
  \item{\code{rt_properties}}{A numeric vector of 6 values required for ARS in the right tail.}
  \item{\code{alpha}}{A numeric scalar representing the uniform step area.}
  \item{\code{tails_method}}{A string, either \code{"ARS"} (Adaptive Rejection Sampling) or \code{"IT"} (Inverse Transform), indicating the sampling method for the tails.}
  \item{\code{grid_bounds}}{A numeric vector specifying the left and right bounds of the target density.}
  \item{\code{cnum}}{An integer representing the cache number of the created grid in memory.}
  \item{\code{symmetric}}{A numeric scalar indicating the symmetry point of the grid, or \code{NULL} if not symmetric.}
  \item{\code{f_params}}{A list of parameters for the target density that the proposal grid is designed for.}
  \item{\code{is_symmetric}}{A logical value indicating whether the proposal grid is symmetric.}
  \item{\code{grid_type}}{A string indicating the type of the generated grid:
  \describe{
    \item{\code{"scaled"}}{The grid is "scalable" and standardized with \code{rate = 1}. This is used when parameter \code{rate} is either \code{NULL} or not provided. Scalable grids are compatible with \code{\link{srexp}}.}
    \item{\code{"custom"}}{The grid is "custom" when \code{rate} is provided. Custom grids are compatible with \code{\link{srexp_custom}}.}
  }}
  \item{\code{target_function_area}}{A numeric scalar estimating the area of the target distribution.}
  \item{\code{dens_func}}{A string containing the hardcoded density function.}
  \item{\code{density_name}}{A string specifying the name of the target density distribution.}
  \item{\code{lock}}{An identifier used for saving and loading the grid from disk.}
}
}
\description{
This function is essential for sampling from any uni-modal or multi-modal log-concave density function.
 It generates a proposal grid that can be utilized for this purpose.
 Simply provide the density function \code{f} and its modes. For enhanced accuracy, include
the log-transform \code{h} of the density and its first derivative \code{h_prime}.
 The grid optimization is pre-configured for efficiency,
but you can customize the grid-building process through various parameters to suit your specific needs.
}
\details{
The grid building process is executed through the construction of constant area rectangles,
 starting from the modes of the target distribution.
For each mode, rectangles are formed as steps around it,
 with a width defined by \eqn{(x_i - x_{i-1})} and a height determined by \eqn{\max(f(x_{i-1}), f(x_i))}.
This method effectively covers the target distribution in a stepped pattern.


The function \code{build_final_grid()} manages the construction of these steps and calculates values critical for the sampling process.
When the resultant grid is used with the \code{stors()} function, these values are cached,
significantly enhancing the computational efficiency and hence improving sampling speed.
 During the optimization process, we aim for a certain grid
size based on L1-3 memory cache size. Therefore, we test the speed of grids of sizes \eqn{2^m} Kb.
 To achieve this, we estimate the uniform step area
based on a certain steps number that leads to the target cache size,
 \eqn{ \alpha = \frac{1}{\text{number of steps}} }.


The speed testing for each possible grid is initially based on a sample size of 1000.
 However, if the user wishes to optimize the grid for a different sample size, they can do so
by specifying the desired sample size using the \code{target_sample_size} argument.


In case the user wants to select a specific number of steps for the proposal grid
and bypass the optimization process, this can be done by specifying a steps number greater than the number of modes by 2 using the \code{steps} argument.
 If the target density is heavy-tailed,
  and the user wishes to stop the grid building process at a certain pre-acceptance threshold, this can be achieved by setting
the acceptance probability threshold \code{theta} \eqn{\theta}.
 Once the steps reach this level of pre-acceptance probability,
  the step construction will end \eqn{ \frac{\min(f(x_i), f(x_{i+1}))}{\max(f(x_i), f(x_{i+1}))} < \theta }.
Alternatively, if the user wishes to create the steps within certain limits on the
x-axis, they can do so by specifying the proposal grid limits using the \code{grid_range} argument.
}
\examples{

# Example 1: Building a Grid for Standard Normal Distribution
# This example demonstrates constructing a grid for a standard normal distribution
# \( f(x) \sim \mathcal{N}(0,1) \),
# and shows the optimization table by setting \code{verbose} to \code{TRUE}.

# Define the density function, its logarithm,
# and its derivative for the standard normal distribution
modes_norm = 0
f_norm <- function(x) { 1 / sqrt(2 * pi) * exp(-0.5 * x^2) }
h_norm <- function(x) { log(f_norm(x)) }
h_prime_norm <- function(x) { -x }

# Build the proposal grid for the standard normal distribution
norm_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_norm,
 f = f_norm, h = h_norm, h_prime = h_prime_norm, verbose = TRUE)

# Plot the generated grid
plot(norm_grid)

# Example 2: Grid for a Bimodal Distribution
# This example shows how to build a grid for sampling from a bimodal distribution,
#combining two normal distributions
# \( f(x) = 0.5 \cdot w_1(x) + 0.5 \cdot w_2(x) \),
# where \( w_1(x) \sim \mathcal{N}(0, 1) \) and \( w_2(x) \sim \mathcal{N}(4, 1) \).

# Define the bimodal density function
f_bimodal <- function(x) {
  0.5 * (1 / sqrt(2 * pi)) * exp(-(x^2) / 2) + 0.5 * (1 / sqrt(2 * pi)) * exp(-((x - 4)^2) / 2)
}
modes_bimodal = c(0.00134865, 3.99865)

# Build the proposal grid for the bimodal distribution
bimodal_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_bimodal, f = f_bimodal)

# Print and plot the bimodal grid
print(bimodal_grid)
plot(bimodal_grid)

# Example 3: Grid with 500 Steps for Bimodal Distribution
# This example demonstrates constructing a grid with 500 steps,
# for the bimodal distribution used in Example 2.

bimodal_grid_500 = build_grid(lb = -Inf, rb = Inf, mode = modes_bimodal, f = f_bimodal, steps = 500)

# Print and plot the grid with 500 steps
print(bimodal_grid_500)

}
\seealso{
\code{\link{stors}}: Function to build and return a sampling function based on the provided grid properties.
}
