---
title: "Sampling from Built-in Distributions using STORS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Sampling_Built_in_distributions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The `stors` package provides efficient sampling from uni- and multimodal distributions using Rejection Sampling techniques. For built-in distributions, STORS offers optimized sampling functions that leverage pre-constructed grids to maximize sampling speed.

In this vignette, we focus on how to use the `stors` package to sample from built-in distributions, demonstrating the simplicity and efficiency of the package's built-in functions.

To sample from any built-in distribution, a proposal grid for each distribution is pre-optimized using 4091 steps when the package is loaded for the first time. This optimization process constructs the grid and stores it in the internal R data directory. The grid is then cached in memory for efficient sampling whenever needed.

You can also visualize the grid data using the \code{plot()} function to better understand its structure.

Hereâ€™s an example of optimizing a grid for the Normal distribution (note: this process is performed automatically when the package is installed and loaded for the first time):

```{r setup, echo = TRUE}

library(stors)

# Optimize a grid for the Normal distribution with 4091 steps
grid <- srnorm_optimize(steps = 4091)

# Visualize the optimized grid
plot(grid)
```


With the optimized grid ready, sampling from a Normal distribution with specific \code{mean} and \code{sd} is straightforward using the \code{srnorm} function.

```{r , echo = TRUE}

# Generating 10 samples from the standard Normal distribution
standard_normal_samples <- srnorm(10, mean = 2, sd = 1)
print(standard_normal_samples)

# Generating 10 samples from a Normal distribution with mean = 4 and standard deviation = 2
# Uncomment the following lines to generate these samples:
# general_normal_samples <- srnorm(10, mean = 4, sd = 2)
# print(general_normal_samples)

```

On the other hand, users can optimize a proposal grid for a specific Normal distribution by calling \code{srnorm_optimize()} and passing the desired \code{mean} and \code{sd} arguments. In this case, a unique grid will be optimized and cached in memory. To sample from this custom grid, the user can use the \code{srnorm_custom()} function by simply specifying the sample size.

```{r , echo = TRUE}

# Optimize a custom proposal grid for N(3, 2)
grid <- srnorm_optimize(mean = 3, sd = 2, steps = 2000)

# Generate a sample of size 10^3 from N(3, 2)
sample <- srnorm_custom(10^3)

# Visualize the generated sample
hist(sample, main = "Histogram of Samples from N(3, 2)", xlab = "Value", col = "skyblue", border = "white")


```


To sample from a truncated Normal distribution, users need to optimize either the scalable grid or a custom grid and specify the truncation bounds using the \code{xl} (lower bound) and \code{xr} (upper bound) arguments.

```{r , echo = TRUE}

# Define the truncation bounds
lower_bound <- -1
upper_bound <- 1

# Optimize the scalable grid with truncation bounds
grid <- srnorm_optimize(xl = lower_bound, xr = upper_bound, steps = 4091)

# Generate samples from the truncated standard Normal distribution
sample <- srnorm(10^3)
hist(sample, main = "Truncated Standard Normal (-1, 1)", xlab = "Value", col = "lightblue", border = "white")

# Generate samples from the truncated Normal distribution N(2, 1)
sample <- srnorm(10^3, mean = 2)
hist(sample, main = "Truncated Normal N(2, 1) (-1, 1)", xlab = "Value", col = "lightgreen", border = "white")


```

The same process can be applied to a custom grid. A custom grid can be truncated and used for sampling by following this example:

```{r , echo = TRUE}

# Define the truncation bounds
lower_bound <- 2
upper_bound <- 6

# Optimize a custom grid with truncation bounds and mean = 4
grid <- srnorm_optimize(mean = 4, xl = lower_bound, xr = upper_bound, steps = 4091)

# Generate samples from the truncated Normal distribution
sample <- srnorm_custom(10^3)
hist(sample, main = "Truncated Custom Normal (2, 6)", xlab = "Value", col = "lightblue", border = "white")


```

The \code{grid_optimizer} functions not only optimize the grid but also return a detailed list describing the properties of the optimized grid. This list provides insights into the grid's structure and characteristics. You can use the base \code{print()} function to view these details or the \code{plot()} function to visualize the grid.

```{r , echo = TRUE}

# Optimize a grid for the Laplace distribution
grid <- srlaplace_optimize(steps = 4091)

# View the details of the optimized grid
print(grid)

# Visualize the grid
plot(grid)

```

In cases where the grid is dense and difficult to visualize in its entirety, you can focus on a specific region by using the \code{plot()} function with the \code{x_min} and \code{x_max} parameters. These parameters allow you to set limits on the x-axis, making it easier to zoom in on areas of interest within the grid.

```{r , echo = TRUE}

# Optimize a grid for the Normal distribution
grid <- srlaplace_optimize(steps = 1020)

# Visualize the entire grid
plot(grid, main = "Full Grid Visualization")

# Focus on a specific region of the grid (e.g., x-axis range -2 to 2)
plot(grid, x_min = -1, x_max = 1, main = "Zoomed-In Grid (-1, 1)")

```

These functionalists of the grid_optimizers and the subsequent visualization tools provide users with in-depth insights into the characteristics of the generated grid, enabling them to understand and fine-tune the sampling process.


If the user is not satisfied with the automatically optimized grid, the grid_optimizers functions offers several arguments for customization. One such argument is `target_sample_size`, which defaults to 1000. If the user wishes to optimize the grid for significantly larger or smaller sample sizes, this argument can be altered.

Another important argument is the pre-acceptance threshold `theta`, which essentially is the ratio between the lower and upper linear bounds for each step. This is typically set to a very small number close to zero. The reason is that the cost of rejecting samples, even in heavy-tailed distributions, is usually less than the cost of using alternative exact sampling methods (like Inverse Transform) for dense grids, as the probability of hitting these inefficient steps is low. However, for very large sample sizes (e.g., 10^9), these inefficient steps might be hit more frequently, leading to an increase in sampling time due to lower efficiency. In such cases, the user can set a higher pre-acceptance threshold using the `theta` parameter.

For users who are less familiar with the target distribution, or want to focus on a specific range of the distribution, the `grid_range` argument can be used. This parameter limits the step construction to a specified range on the x-axis, offering more control over the grid structure.

```{r , echo = TRUE}
# Customizing the grid for a specific sample size
custom_grid = srnorm_optimize(target_sample_size = 10000)

print(custom_grid)

plot(custom_grid)

# Customizing the grid with a specific pre-acceptance threshold
custom_grid_high_theta = srnorm_optimize(theta = 0.9)

print(custom_grid_high_theta)

plot(custom_grid_high_theta)

# Customizing the grid within a specific range
custom_grid_range = srnorm_optimize(grid_range = c(-1, 1))

print(custom_grid_range)

plot(custom_grid_range)

```

In addition to the `target_sample_size`, `theta`, and `grid_range` parameters, users have the flexibility to directly control the number of steps in the proposal grid. This can be particularly useful when users have specific requirements or preferences for the granularity of the grid. To specify the number of steps, the `steps` argument can be passed to the grid_optimizer function.

By setting the `steps` parameter, users can determine the resolution of the grid, which can impact the balance between computational efficiency and the granularity of the sampling. A higher number of steps typically provides a more detailed grid, potentially leading to more precise sampling, but at the cost of increased memory usage and possibly longer computation times.

```{r , echo = TRUE}
# Customizing the grid with a specific number of steps
custom_grid_steps = srnorm_optimize(steps = 50)

plot(custom_grid_steps)

custom_grid_steps = srnorm_optimize( steps = 500)

plot(custom_grid_steps)

```


The user can also create a symmetric proposal for built-in distributions by setting the \code{symmetric} argument to the value around which the target density is symmetric.

Example: Creating a Symmetric Proposal for the Standard Normal Distribution

In this example, we create a symmetric proposal for the standard Normal distribution. Before doing so, we first delete all previously constructed non-symmetric grids (both scaled and custom) using the \code{delete_build_in_grid()} function.
```{r, echo = FALSE}

# Delete all non-symmetric grids for the Normal distribution
delete_build_in_grid(sampling_function = "srnorm", grid_type = "scaled")
delete_build_in_grid(sampling_function = "srnorm", grid_type = "custom")

# Create a symmetric proposal grid for the standard Normal distribution
grid <- srnorm_optimize(symmetric = 0, steps = 2040)

# Visualize the symmetric proposal grid
plot(grid)

```


Sampling from Truncated Distributions
One of the standout features of STORS is its ability to sample efficiently from truncated distributions. To sample from a truncated distribution, the user simply needs to specify the upper and lower truncation bounds using the \code{xl} (lower bound) and \code{xr} (upper bound) arguments in the \code{grid_optimizer} function.

Example: Sampling from a Truncated Standard Normal Distribution
In this example, we demonstrate how to sample from a truncated standard Normal distribution with truncation bounds at \code{-1} and \code{1}.

```{r, echo = FALSE}

# Delete all non-symmetric grids for the Normal distribution
delete_build_in_grid(sampling_function = "srnorm", grid_type = "scaled")
delete_build_in_grid(sampling_function = "srnorm", grid_type = "custom")

# Optimize the grid for a truncated standard Normal distribution
grid <- srnorm_optimize(mean = 0, sd = 1, xl = -1, xr = 1, steps = 4020)

# Visualize the truncated grid
plot(grid, main = "Truncated Standard Normal Grid (-1, 1)", xlab = "Value", col = "lightblue")

# Generate 10^4 samples from the truncated distribution
sample <- srnorm_custom(10^4)

# Visualize the generated samples
hist(sample, main = "Histogram of Samples from Truncated Standard Normal", 
     xlab = "Value", col = "lightgreen", border = "white")

```

There are many built-in functions in stors, the list below shows all available functions that can be used directly by the user after optimizing the grids:

```{r, echo = FALSE}
funcs = character()
for( name in names(stors:::pbgrids)){
  funcs = cat(funcs," ",name)
}
```

For each built-in distribution, there is a corresponding proposal distribution optimizer that can be invoked using the format \code{"sampling_function_name"_optimize()}. This function optimizes the grid for the specified distribution, enabling efficient sampling.



