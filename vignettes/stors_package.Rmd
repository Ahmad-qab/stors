---
title: "stors package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{stors package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The aim of the [stors] package is to generate samples from uni- and multimodal distributions using the Rejection Sampling technique. Stors stands out for its ability to leverage the system's capabilities to optimize the sampling process.

Stors maximizes the sampling speed from the proposal distribution by constructing steps with uniform areas that cover the target distribution from which sampling is needed. To address potential efficiency issues in heavy and light-tailed distributions, we switch to Adaptive Rejection Sampling (ARS) for the tails, specifically for the grids created by the user. Fortunately, since ARS is used only for the tails, it eliminates the requirement for log concavity in most distributions, allowing us to cover a wide range of distributions.

To use the [stors] package, we need to differentiate between two phases. The first phase involves building the grid for the proposal distribution. The second step is caching this grid in memory for sampling. This ensures optimum speed performance, as the proposal data is constructed independently from the sampling process. Most R base sampling functions are already covered in the stors package, making sampling straightforward.

## Sampling from Built-in Distrubutions

To sample from any built-in distribution, the user only needs to run the grid_optimizer() function once when the package is loaded for the first time. This creates an optimized grid and stores it in the internal R data directory, so it can be loaded and used for sampling when needed. Also, you can visualize the grid data using the plot() function.

Here's an example of how to optimize a grid for the standard normal distribution:

```{r setup, echo = TRUE}

library(stors)

norm_grid = grid_optimizer("srnorm")

```


With the optimized grid ready, sampling from the standard normal distribution can be easily achieved using the `srnorm` function. For more general normal distributions, where the mean and standard deviation are not zero and one respectively, the `srnorm_scaled` function can be used.

```{r , echo = TRUE}

# Generating samples from the standard normal distribution
standard_normal_samples = srnorm(10)
print(standard_normal_samples)

# Generating samples from a normal distribution with mean = 4 and standard deviation = 2
general_normal_samples = srnorm_scaled(10, mu = 4, sd = 2)
print(general_normal_samples)

```

One of the powerful features of the `stors` package is its ability to sample from truncated distributions efficiently. This is particularly useful when the area of interest in a distribution is limited to a specific range, and you want to avoid unnecessary computations outside this range. 

The `stors` package simplifies the process of sampling from truncated distributions. For standard normal distributions, the `srnorm_truncate()` function enables this feature. Users just need to provide the truncation bounds, and the function returns a sampler that is confined to these bounds. This means that the sampling is focused only within the specified range, making the process more efficient, especially when the cumulative distribution function (CDF) does not need to be evaluated, which is the case for a grid with wide steps range covering most of the target density domain. 

Here's an example of how to use `srnorm_truncate()` to create a sampler for a truncated normal distribution:

```{r , echo = TRUE}

# Defining the truncation bounds
lower_bound = -1
upper_bound = 1

# Creating a sampling function for a truncated normal distribution
truncated_normal_sampler = srnorm_truncate(xl = lower_bound, xr = upper_bound)

# Generating samples from the truncated normal distribution
truncated_samples = truncated_normal_sampler(100)
hist(truncated_samples)

```


The `grid_optimizer()` function not only optimizes the grid but also returns a list detailing the properties of the optimized grid. This list can be used to understand the grid's structure and properties. To view these details, you can use the base `print()` function. Additionally, the `plot()` function provides a visual representation of the grid.

```{r , echo = TRUE}

print(norm_grid)

plot(norm_grid)

```

In cases where the grid is very dense and challenging to visualize in its entirety, you can focus on a specific region of the grid. The `plot()` function allows you to specify the limits on the x-axis using `x_min` and `x_max` parameters. This can be particularly useful for zooming into areas of interest within the grid.

```{r , echo = TRUE}

plot(norm_grid, x_min = -0.1, x_max = 0)

```

These functionalists of the grid_optimizer() and the subsequent visualization tools provide users with in-depth insights into the characteristics of the generated grid, enabling them to understand and fine-tune the sampling process.

If the user is not satisfied with the automatically optimized grid, the `grid_optimizer()` function offers several arguments for customization. One such argument is `target_sample_size`, which defaults to 1000. If the user wishes to optimize the grid for significantly larger or smaller sample sizes, this argument can be altered.

Another important argument is the pre-acceptance threshold `theta`, which essentially is the ratio between the lower and upper linear bounds for each step. This is typically set to a very small number close to zero. The reason is that the cost of rejecting samples, even in heavy-tailed distributions, is usually less than the cost of using alternative exact sampling methods (like Inverse Transform) for dense grids, as the probability of hitting these inefficient steps is low. However, for very large sample sizes (e.g., 10^9), these inefficient steps might be hit more frequently, leading to an increase in sampling time due to lower efficiency. In such cases, the user can set a higher pre-acceptance threshold using the `theta` parameter.

For users who are less familiar with the target distribution, or want to focus on a specific range of the distribution, the `grid_range` argument can be used. This parameter limits the step construction to a specified range on the x-axis, offering more control over the grid structure.

```{r , echo = TRUE}
# Customizing the grid for a specific sample size
custom_grid = grid_optimizer("srnorm", target_sample_size = 10000)

print(custom_grid)

plot(custom_grid)

# Customizing the grid with a specific pre-acceptance threshold
custom_grid_high_theta = grid_optimizer("srnorm", theta = 0.9)

print(custom_grid_high_theta)

plot(custom_grid_high_theta)

# Customizing the grid within a specific range
custom_grid_range = grid_optimizer("srnorm", grid_range = c(-1, 1))

print(custom_grid_range)

plot(custom_grid_range)

```

In addition to the `target_sample_size`, `theta`, and `grid_range` parameters, users have the flexibility to directly control the number of steps in the proposal grid. This can be particularly useful when users have specific requirements or preferences for the granularity of the grid. To specify the number of steps, the `steps` argument can be passed to the `grid_optimizer()` function.

By setting the `steps` parameter, users can determine the resolution of the grid, which can impact the balance between computational efficiency and the granularity of the sampling. A higher number of steps typically provides a more detailed grid, potentially leading to more precise sampling, but at the cost of increased memory usage and possibly longer computation times.

```{r , echo = TRUE}
# Customizing the grid with a specific number of steps
custom_grid_steps = grid_optimizer("srnorm", steps = 50)

plot(custom_grid_steps)

custom_grid_steps = grid_optimizer("srnorm", steps = 500)

plot(custom_grid_steps)

```

There are many built-in functions in stors, the list below shows all available functions that can be used directly by the user after optimizing the grids:

```{r, echo = FALSE}
funcs = character()
for( name in stors:::stors_env$grids$biultin$names){
  funcs = cat(funcs," ",name)
}
```

## Sampling from Users' Distributions

For distributions not covered by the built-in functions and that satisfy the log concavity condition, users have the flexibility to create their own grids using the `grid_builder()` function. This function is designed to handle a variety of distributions by accepting a range of parameters tailored to the specific needs of the distribution being sampled from.

The following example demonstrates the process of sampling from a bimodal normal distribution. Let's assume that the user wants to sample from a bimodal distribution, which is a combination of two normal distributions $f(x) = 0.5 w_1(x) + 0.5 w_2(x)$, where $w_1(x) \sim N(0, 1)$ and $w_2(x) \sim N(4, 1)$:

$$
f(x) =  0.5 \frac{1}{\sqrt{2 \pi}}  \exp\left(-\frac{x^2}{2}\right) + 0.5  \frac{1}{\sqrt{2 \pi}} \exp\left(-\frac{(x - 4)^2}{2}\right)
$$

To sample from the tails of $f(x)$ using ARS, we need the log transformation of $f(x)$, $h(x) = log(f(x))$, and its first derivative $h_\text{prime}(x) = \frac{d}{dx} h(x)$. Also, the modes of $f(x)$ are required to build the steps part of the proposal distribution, which in this case are 0.00134865 and 3.99865.

```{r , echo = TRUE}

modes_bi = c(0.00134865,3.99865)

f_bi <- function(x) {
  0.5 * (sqrt(2 * pi))^(-1) * exp(-(x^2)/2) + 0.5 * ( sqrt(2 * pi))^(-1) * exp(-((x - 4)^2)/2)
}

h_bi <- function(x) log(f_bi(x))


h_prime_bi <- function(x) {
  (-(exp(-1/2 * (-4 + x)^2) * 0.5 * (-4 + x))/sqrt(2 * pi) - (exp(-x^2/2) * 0.5 * x)/sqrt(2 * pi))/((exp(-x^2/2) * 0.5)/sqrt(2 * pi) + (exp(-1/2 * (-4 + x)^2) * 0.5)/sqrt(2 * pi))
}

bi_grid = build_grid(lb = -Inf, rb = Inf, modes = modes_bi, f = f_bi, h = h_bi, h_prime = h_prime_bi)


```

After building the desired grid with `grid_builder()`, users can explore its properties using the `print()` function and visualize its structure using the `plot()` function. This step is similar to what was done previously with the built-in grid and helps in understanding the grid's configuration and ensuring that it aligns with the requirements of the target distribution.

```{r , echo = TRUE}

# Printing the properties of the custom grid
print(bi_grid)

# Visualizing the custom grid
plot(bi_grid)

```

Once the grid is configured and validated, it can be passed to the `stors()` function. `stors()` caches the grid in memory, providing fast access for sampling, and returns a sampler function for the target distribution. This sampler function can then be used to generate samples as needed.

```{r , echo = TRUE}

# Creating a sampler function using the custom grid
bi_sampler = stors(bi_grid)

# Generating samples from the target distribution
samples = bi_sampler(10)
print(samples)

```

## Saving, Loading and Deleting Users' Grids

The grid stored in `bi_grid` will not be preserved across sessions. Therefore, if the user is satisfied with the sampling results and wishes to store the grid for future use, they should save the grid using the `save_grid()` function. This function takes the optimized grid and a filename chosen by the user to save the grid in the internal R data directory on their machine. This is recommended if the user plans to use the grid frequently across sessions, to avoid re-optimizing the grid in future sessions.

```{r , echo = TRUE}

save_grid(bi_grid,"bimodal_grid")


```

```{r , include = FALSE}
for (i in 1:3) {
  save_grid(bi_grid,paste0("bimodal_grid_",i))
}

```

To load and use the grid in future sessions, the user only needs to use the `load_grid()` function.

```{r , echo = TRUE}

bi_grid = load_grid("bimodal_grid")

```

In case the user wants to view a list of all previously stored grids, the `print_grids()` function will provide the user with all stored grids.

```{r , echo = TRUE}

print_grids()

```

Be aware that the saved grid can be quite large in size, depending on the user's system. Therefore, if the user wants to delete a grid, the `delete_grid()` function can be used by providing the grid's name.

```{r , echo = TRUE}

delete_grid("bimodal_grid")

print_grids()

```

```{r , include = FALSE}
for (i in 1:3) {
  delete_grid(paste0("bimodal_grid_",i))
}

```