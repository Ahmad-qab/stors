---
title: "stors package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{stors package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The aim of the [stors] package is to generate samples from uni- and multimodal distributions using the Rejection Sampling technique. Stors stands out for its ability to leverage the system's capabilities to optimize the sampling process.

Stors maximizes the sampling speed from the proposal distribution by constructing steps with uniform areas that cover the target distribution from which sampling is needed. To address potential efficiency issues in heavy and light-tailed distributions, we switch to Adaptive Rejection Sampling (ARS) for the tails, specifically for the grids created by the user. Fortunately, since ARS is used only for the tails, it eliminates the requirement for log concavity in most distributions, allowing us to cover a wide range of distributions.

To use the [stors] package, we need to differentiate between two phases. The first phase involves building the grid for the proposal distribution. The second step is caching this grid in memory for sampling. This ensures optimum speed performance, as the proposal data is constructed independently from the sampling process. Most R base sampling functions are already covered in the stors package, making sampling straightforward.

## Sampling from Built-in Distrubutions

To sample from any built-in distribution, the user only needs to run the `grid_optimizer()` function once when the package is loaded for the first time. This creates an optimized grid and store it in the internal R data directory, so it can be loaded and used for sampling when needed.

The following provides an example of optimizing a grid to sample from standard normal distribution using. The sampling 10 samples using the function 'srnorm()'.

```{r setup, echo = TRUE}

library(stors)

grid_optimizer("srnorm")

srnorm(10)

```

There are many built in functions in stors, the list below shows all available functions that can be used directly by the used after optimizing the grids:
```{r, echo = FALSE}
funcs = character()
for( name in stors:::stors_env$grids$biultin$names){
  funcs = cat(funcs," ",name)
}
```

## Sampling from Users' Distributions

For distributions not covered by the built-in functions, users can generate their own grid using the `grid_build()` function. This function accepts arguments such as `modes` (a scalar for uni-modal distributions or a vector for multimodal ones), `f` (the target density function of the sampling distribution), `h` (the log transform of the target distribution), `h_prime` (the first derivative of `h`), `lb` (the lower bound), and `rb` (the upper bound of the target distribution).

The following example demonstrates the process of sampling from a bimodal normal distribution. Let's assume that the user wants to sample from a bimodal distribution, which is a combination of two normal distributions $f(x) = 0.5 w_1(x) + 0.5 w_2(x)$, where $w_1(x) \sim \mathcal{N}(0, 1)$ and $w_2(x) \sim \mathcal{N}(4, 1)$:

$$
f(x) =  0.5 \frac{1}{\sqrt{2 \pi}}  \exp(-\frac{x^2}{2}) + 0.5  \frac{1}{\sqrt{2 \pi}} \exp(-\frac{(x - 4)^2}{2})
$$

To sample from the tails of $f(x)$ using ARS, we need the log transformation of $f(x)$, $h(x) = log(f(x))$ and it's first derivative $h_\text{prime}(x) = \frac{d}{dx} h(x)$. Also, the modes of $f(x)$ are required to build the steps part of the proposal distribution, which in this case are 0 and 4.

```{r , echo = TRUE}

modes_bi = c(0,4)

f_bi <- function(x) {
  0.5 * (sqrt(2 * pi))^(-1) * exp(-(x^2)/2) + 0.5 * ( sqrt(2 * pi))^(-1) * exp(-((x - 4)^2)/2)
}

h_bi <- function(x) log(f_bi(x))


h_prime_bi <- function(x) {
  (-(exp(-1/2 * (-4 + x)^2) * 0.5 * (-4 + x))/sqrt(2 * pi) - (exp(-x^2/2) * 0.5 * x)/sqrt(2 * pi))/((exp(-x^2/2) * 0.5)/sqrt(2 * pi) + (exp(-1/2 * (-4 + x)^2) * 0.5)/sqrt(2 * pi))
}

bi_grid = build_grid(lb = -Inf, rb = Inf, mode = modes_bi, f = f_bi, h = h_bi, h_prime = h_prime_bi)


```


After building the desired grid, it should be passed to function `stors()`. This function will cache the grid in memory for fast access and return the sampler function of the target distribution.

```{r , echo = TRUE}

bi_sampler = stors(bi_grid)

bi_sampler(10)

```

## Saving, Loading and Deleting Users' Grids

The grid stored in `bi_grid` will not be preserved across sessions. Therefore, if the user is satisfied with the sampling results and wishes to store the grid for future use, they should save the grid using the `save_grid()` function. This function takes the optimized grid and a filename chosen by the user to save the grid in the internal R data directory on their machine. This is recommended if the user plans to use the grid frequently across sessions, to avoid re-optimizing the grid in future sessions.

```{r , echo = TRUE}

save_grid(bi_grid,"bimodal_grid")


```

```{r , include = FALSE}
for (i in 1:3) {
  save_grid(bi_grid,paste0("bimodal_grid_",i))
}

```

To load and use the grid in future sessions, the user only needs to use the `load_grid()` function.

```{r , echo = TRUE}

bi_grid = load_grid("bimodal_grid")

```

In case the user wants to view a list of all previously stored grids, the `print_grids()` function will provide the user with all stored grids.

```{r , echo = TRUE}

print_grids()

```

Be aware that the saved grid can be quite large in size, depending on the user's system. Therefore, if the user wants to delete a grid, the `delete_grid()` function can be used by providing the grid's name.

```{r , echo = TRUE}

delete_grid("bimodal_grid")

print_grids()

```

```{r , include = FALSE}
for (i in 1:3) {
  delete_grid(paste0("bimodal_grid_",i))
}

```